// 포인터와 2차원 배열
//  : 2차원 배열의 저장도 실제로는 1차원 배열과 차이 없음을 기억하면 간단 (n차원 배열도 메모리 할당은 선형성을 띄는 연속적 할당이기 때문)

//    ex) int array[3][3] = {8, 2, 4, 1, 5, 6};					
//        -> 순서는 1,1 -> 1,2 -> 1.3  ~~ 이런식으로 열이 먼저 선행되서 입력
//           (= 메모리 구조도 실제로는 [0][0] ~ [0][x] -> [x][0] ~ [x][x] 이런 순으로 입력되어, [0][0]을 시작으로 자료형 크기 만큼 움직이며 순차적으로 메모리에 할당)

//                    [0][0]          [0][1]          [0][2]
//          [0][0]      8               2               4				<- 1~3 번째 입력값
//          [1][0]      1               5               6				<- 4~6 번째 입력값
//          [2][0]      0               0               0

//          배열주소               배열값           메모리 주소
//          [0][0]                  8               [0][0] 주소값
//          [0][1]                  2               [0][0]  + 4btye(int 크기)
//          [0][2]                  4               [0][0]  + 8btye(4*2)
//          [1][0]                  1               [0][0]  + 12btye(4*3)
//          ....................................................
//          [2][2]                  0               [0][0]  + 32btye(4*8)


// (중요) N차원 배열과 포인터의 표기형식 관계...

//      2. (중요!) 2차원 array변수의 이중성
//          - 2차원 array변수 자신 : 포인터변수 (2차원 array 자신의 시작주소값(= &2차원배열변수[0][0] = 2차원배열변수[0])을 의미)
//          - []와 함께 경우( &2차원배열변수[1][0] = 2차원배열변수[1] )
//             1. 2차원배열변수[]   : 1차원에 해당하는 부분을 의미하는 변수의 표기값 그 자체가 주소를 의미하는 '포인터변수'
//             2. 2차원배열변수[][] : 배열 안에 위치하는 단순 자료형 변수 (= 포인터와 관련성이 1도 없음)

//           ex) 2차원 배열의 경우1 ( 3*3을 기준 int* p = array2d[3] 가정 )

//               포인터식 표현      배열식 표현   : 2차원 배열로 선언된 배열의 포인터의 경우 1차원까지를 표기한 경우는 그 자체가 주소값으로서 의미를 가짐(&가 필요없음)
//                *(p[3] + 3)   =     p[3][3]
//                  p[3] + 3    =     &p[3][3]

//           ex) 2차원 배열의 경우2 ( 3*3을 기준 int* p = array2d 가정 )

//               포인터식 표현      배열식 표현   : 2차원 배열로 선언된 배열의 포인터의 경우, 2차원 배열변수 그 자체를 받을시 p = &array2d[0][0]와 같음
//                  *(p + 8)    =     p[3][3]       -> 포인터변수라도 배열식으로 쓰면 기본적으로 주소값이 아닌 일반 값을 참조 (그냥 배열처럼 쓰면 배열같이 생각하자) 
//                    p + 8     =     &p[3][3]

//      3. (중요!) 3차원 array변수의 이중성
//          - 2차원 array변수 자신 : 포인터변수 (3차원 array 자신의 시작주소값(= &3차원배열변수[0][0][0] = 3차원배열변수[0][0])을 의미)
//          - []와 함께 경우( &3차원배열변수[1][0][0] = 3차원배열변수[1][0] = 3차원배열변수[2])
//             1. 3차원배열변수[]     : 1차원에 해당하는 부분을 의미하는 변수의 표기값 그 자체가 주소를 의미하는 '포인터변수'
//             2. 3차원배열변수[][]   : 2차원에 해당하는 부분을 의미하는 변수의 표기값 그 자체가 주소를 의미하는 '포인터변수'
//             3. 3차원배열변수[][][] : 배열 안에 위치하는 단순 자료형 변수 (= 포인터와 관련성이 1도 없음)

//      # (결론) (N-1)차원까지의 배열표기 = N차원 배열에서의 해당 차원에 해당하는 주소값 의미
//        -> (중요!) But! 3차원 이상의 배열들을 관리하기 위해서는 '다차원 포인터변수로 이뤄진 X중 포인터 배열'을 다룰 수 있어야 함..
//           -> 이를 위해서는 다중 포인터 개념(day12-4.c로...)이 선행되어야 하며, 다차원 배열과 포인터와 관련된 내용을 배워야함 (day14-6.c로..) )


// 원하는 사이즈보다 큰 배열을 생성한뒤, 포인터와 for문으로 max+1을 쓰지말고 표현해라   =    printf("%5d", *p_a++);를 고쳐서 포인터형식으로 배열값 나열이 제대로 되게 하면 됨
#include <stdio.h>
#define max 3
int main() {

    // 배열은 일부러 한차원 더 큰거로
    int a[max + 1][max + 1] = { 0 }, k = 0;

    // (중요) a[0] = &a[0][0];
    int* p_a = a[0]; 

    printf("\n2차원 배열 값 입력\n");

    for (int i = 0; i < max; i++) {
        for (int j = 0; j < max; j++) {
            a[i][j] = ++k;
            printf("%5d", a[i][j]);
        }
        printf("\n");
    }

    printf("\n2차원 배열 값 출력 (배열 접근)\n");

    for (int i = 0; i < max; i++) {
        for (int j = 0; j < max; j++) {
            printf("%5d", a[i][j]);
        }
        printf("\n");
    }

    printf("\n2차원 배열 값 출력 (포인터 접근)\n");
    printf(" ( 숨은 0값 찾기 ) \n");

    //  포인터변수의 주소값으로 낸 답안 (이쪽이 더 범용성이 높음)
    for (int i = 0; i < max; i++) {
        for (int j = 0; j < max; j++) {
            
            // printf("%5d", *p_a++);                   <- 이 녀석은 무지성으로 배열크기 생각안하고 연산하니 문제
            printf("%5d", *(p_a + i * (max+1) + j) );   // a[0]을 기준으로 (MAX값 +1) , (2* MAX값 +1) ~~ 가 전부 0이니 이녀석을 피해가면 됨
        }
        printf("\n");
    }

    printf("\n");
    p_a = a;

    // 역참조 값으로 낸 모범답안
    for (int i = 0; i < max; i++) {
        for (int j = 0; j < max; j++) {
            
            // printf("%5d", *p_a++);
            printf("%5d", *p_a + i * max + j);      // 이쪽은 단순히 뽑아야 할 값이 등차수열이라 맞아 떨어진거에 가까움
        }
        printf("\n");
    }

    printf("\n");
    return 0;
}
