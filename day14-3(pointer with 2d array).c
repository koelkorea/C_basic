// 포인터와 2차원 배열
//  : 2차원 배열의 저장도 실제로는 1차원 배열과 차이 없음을 기억하면 간단 (n차원 배열도 메모리 할당은 선형성을 띄는 연속적 할당이기 때문)

//    ex) int array[3][3] = {8, 2, 4, 1, 5, 6};					
//         -> 순서는 1,1 -> 1,2 -> 1.3  ~~ 이런식으로 열이 먼저 선행되서 입력
//            (= 메모리 구조도 실제로는 [0][0] ~ [0][x] -> [x][0] ~ [x][x] 이런 순으로 입력되어, [0][0]을 시작으로 자료형 크기 만큼 움직이며 순차적으로 메모리에 할당)

//                    [0][0]          [0][1]          [0][2]
//          [0][0]      8               2               4				<- 1~3 번째 입력값
//          [1][0]      1               5               6				<- 4~6 번째 입력값
//          [2][0]      0               0               0

//          ------------------------------------------------------------------
//          배열주소              배열값            메모리 주소
//          ------------------------------------------------------------------
//          [0][0]                  8               [0][0] 주소값
//          [0][1]                  2               [0][0] + 4btye  (int 크기)
//          [0][2]                  4               [0][0] + 8btye  (4 * 2)
//          [1][0]                  1               [0][0] + 12btye (4 * 3)
//          ..................................................................
//          [2][2]                  0               [0][0] + 32btye (4 * 8)


// (중요) N차원 배열과 포인터의 표기형식 관계...
//   : (결론) (N-1)차원까지의 배열표기 = N차원 배열에서의 해당 차원에 해당하는 주소값 의미
//       -> (중요!) But! 3차원 이상의 배열들을 관리하기 위해서는 '다차원 포인터변수로 이뤄진 X중 포인터 배열'을 다룰 수 있어야 함..
//            -> 그냥 애지간하면 1중 포인터변수 만들어 둬서, 거기다두고 꼴리는 대로 대입하면, 내가 쓴 배열주소가 X중 포인터니 뭐니 신경 쓸 필요 없이 직관적으로 사용가능!

//      2. (중요!) 2차원 array변수의 이중성
//          - 2차원 array변수 자신
//             : 해당 2차원 배열의 시작주소값을 의미하는 포인터변수 
//               ( 2차원배열변수 = &2차원배열변수[0][0] = 2차원배열변수[0] )

//               ex) 2차원 배열의 경우1 ( 3 * 3 배열을 기준 int* p = array2d명[3] 가정 )
                 
//                   포인터식 표현      배열식 표현   : 2차원 배열의 포인터의 경우, 2차원 배열변수가 1차원까지만 표기한 배열이 대입되는 경우 
//                    *(p[3] + 3)   =      p[3][3]       -> 그 자체가 해당 배열의 각 1차원 라인의 시작주소값으로서 의미를 가짐 (&가 필요없음)
//                      p[3] + 3    =     &p[3][3]
                 
//               ex) 2차원 배열의 경우2 ( 3 * 3 배열을 기준 int* p = array2d명 가정 )
                 
//                   포인터식 표현      배열식 표현   : 배열의 포인터변수가 2차원 배열변수 그 자체를 받는다면, 포인터변수 p = & array2d[0][0]; 의 의미와 같음
//                      *(p + 8)    =      p[3][3]       -> 포인터변수라도 배열식으로 표기한다면, 기본적으로 주소값이 아닌 해당 배열의 index에 놓인 일반 값을 참조 (그냥 배열처럼 쓰면 배열같이 생각하자) 
//                        p + 8     =     &p[3][3]

//          - []와 함께하는 경우( &2차원배열변수[1][0] = 2차원배열변수[1] )
//             1. 2차원배열변수[]   : 1차원에 해당하는 부분을 의미하는 변수의 표기값 그 자체가 주소를 의미하는 '포인터변수'
//             2. 2차원배열변수[][] : 배열 안에 위치하는 단순 자료형 변수 (= 포인터와 관련성이 1도 없음)

//             ex) int a[5][5] = {0};
//                  -> int *p = a[2]라면,
//                     -> (중요) a[2] = &a[2][0] 유추 가능 

//                 1) a는 상수 포인터
//                 2) a는 int 자료형 타입 집합의 시작주소 위치
//                         -> *(a[2] + 2) ==  a[2][2]
//                         ->   a[2] + 2  == &a[2][2] 


// 원하는 사이즈보다 큰 배열을 생성한뒤, 포인터와 for문으로 max + 1을 쓰지말고 표현해라 =  printf("%5d", *p_a++);를 고쳐서 포인터형식으로 배열값 나열이 제대로 되게 하면 됨
#include <stdio.h>
#define max 3
int main() {

    // 배열은 일부러 한차원 더 큰거로
    int a[max + 1][max + 1] = { 0 }, k = 0;

    // (중요) a[0] = &a[0][0];
    int* p_a = a[0]; 

    printf("\n2차원 배열 값 입력\n");

    for (int i = 0; i < max; i++) {
        for (int j = 0; j < max; j++) {
            a[i][j] = ++k;
            printf("%5d", a[i][j]);
        }
        printf("\n");
    }

    printf("\n2차원 배열 값 출력 (배열 접근)\n");

    for (int i = 0; i < max; i++) {
        for (int j = 0; j < max; j++) {
            printf("%5d", a[i][j]);
        }
        printf("\n");
    }

    printf("\n2차원 배열 값 출력 (포인터 접근)\n");
    printf(" ( 숨은 0값 찾기 ) \n");

    //  포인터변수의 주소값으로 낸 답안 (이쪽이 더 범용성이 높음)
    for (int i = 0; i < max; i++) {
        for (int j = 0; j < max; j++) {
            
            // printf("%5d", *p_a++);                        <- 이 녀석은 무지성으로 배열크기 생각안하고 연산하니 문제
            printf("%5d", *(p_a + i * (max + 1) + j) );     // a[0]을 기준으로 (MAX값 +1) , (2* MAX값 +1) ~~ 가 전부 0이니 이녀석을 피해가면 됨
        }
        printf("\n");
    }

    printf("\n");
    p_a = a;

    // 역참조 값으로 낸 모범답안
    for (int i = 0; i < max; i++) {
        for (int j = 0; j < max; j++) {
            
            // printf("%5d", *p_a++);
            printf("%5d", *p_a + i * max + j);      // 이쪽은 단순히 뽑아야 할 값이 등차수열이라 맞아 떨어진거에 가까움
        }
        printf("\n");
    }

    printf("\n");
    return 0;
}
