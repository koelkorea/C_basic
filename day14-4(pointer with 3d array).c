// (중요) N차원 배열과 포인터의 표기형식 관계...
//   : (결론) (N-1)차원까지의 배열표기 = N차원 배열에서의 해당 차원에 해당하는 주소값 의미
//       -> (중요!) But! 3차원 이상의 배열들을 관리하기 위해서는 '다차원 포인터변수로 이뤄진 X중 포인터 배열'을 다룰 수 있어야 함..
//            -> 그냥 애지간하면 1중 포인터변수 만들어 둬서, 거기다두고 꼴리는 대로 대입하면, 내가 쓴 배열주소가 X중 포인터니 뭐니 신경 쓸 필요 없이 직관적으로 사용가능!

//      3. (중요!) 3차원 array변수의 이중성

//          - 3차원 array변수 자신
//             1. 단독으로 쓸 경우 
//                 : 쓰레기주소값 (= 단독으로 쓴 '3차원배열변수'는 진짜 3차원배열변수[0][0][0]와 어떤 연관관계도 찾을 수 없음)
//                    -> 3차원 array변수 자신값이 쓰레기인 이유
//                        : 다차원 배열의 시작 주소를 저장하고 있지만, 이 주소는 다차원 배열의 첫 번째 요소가 아니기 때문

//             2. (중요) 포인터변수에 대입 시
//                 : 해당 3차원 배열의 시작주소값을 의미하는 포인터변수 
//                   ( 3차원배열변수 = &3차원배열변수[0][0][0] = 3차원배열변수[0][0] = 3차원배열변수[0] )


//          - []와 함께하는 경우( &3차원배열변수[1][0][0] = 3차원배열변수[1][0] = 3차원배열변수[2])
//             1. 3차원배열변수[]     : 1차원에 해당하는 부분을 의미하는 변수의 표기값 그 자체가 주소를 의미하는 '포인터변수' 
//                  -> (중요!) 컴파일러에 따라 단독으로 쓴 '3차원배열변수[][]' 진짜 3차원배열변수[][][0]의 주소값을 저장하는 2중 포인터변수로 해석되기도 함
//             2. 3차원배열변수[][]   : 2차원에 해당하는 부분을 의미하는 변수의 표기값 그 자체가 주소를 의미하는 '포인터변수'
//             3. 3차원배열변수[][][] : 배열 안에 위치하는 단순 자료형 변수 (= 포인터와 관련성이 1도 없음)


//    # (중요!!) 3차원 이상의 배열의 경우 배열변수 의 중의성을 활용하여 주소값을 표기하는건 유용할 수는 있어도, 포인터연산이 들어가는 순간 해석에 따라 의미가 중의적으로 변할 수 있음..
//        -> 고차원 배열의 경우 배열변수를 안이하게 사용하고, 포인터연산식을 대충세우면...? 중의성으로 인해 [코드의 의미를 헷갈림 + 의도하지 못한 결과 + 유지보수 X같음] 3콤보에 시달릴 수 있음
//            -> 따라서, 고차원 배열의 포인터연산을 통해 메모리영역을 참조하는 식을 세울때는.. 최대한 ()를 많이 써서 의미를 명확하게 유도하도록 노력하자..

//           ex) int score_3D[5][5][5] = { 2, 4, 8, 10, .... , 250 };
//               int* pScore2 = score_3D[2];

//               [예시1] 
//                *(pScore2 + i) != *(score_3D[2] + i)    ->   *(pScore2 + i) = *(*(score_3D[2] + i))
//                   -> 해당 상황에서 *(pScore2 + i) = *(score_3D[2] + i)로 치환되기에 같은 값이 나와야 하지만... 전자는 제대로 역참조가 되고, 후자는 주소값이 튀어나옴
//                      -> *(pScore2 + i) = *(score_3D[2] + i)은 분명 참이지만, 컴파일러에 따라 해석되는 방식이 다른 상황에서 하필 주소값이 나온 참사... *(score_3D[2] + i)을 다시 역참조를 해주면 문제없음 
//                         -> 정황상 C언어는 score_3D[2]를 score_3D[2][0][0]의 주소값을 담은 2중 포인터변수로 두는것이 포착됨

//                             ex)  score_3D[2] =  score_3D[2][0] = &score_3D[2][0][0]
//                                 *score_3D[2] = *score_3D[2][0] =  score_3D[2][0][0]

//               [예시2] 
//                *(*score_3D[2] + i) != *(*(score_3D[2] + i))
//                   -> 비슷해 보이지만, *score_3D[2] + i와 *(score_3D[2] + i)의 ()를 씌었냐의 차이로 해석이 180도 달라짐
//                      -> *(*score_3D[2] + i)
//                           : 단순 &score_3D[2][0][0]에 i만큼의 주소값을 더해서 이를 역참조한 값(= 얘도 주소값)을 역참조한 score_3D[2][0][i]값

//                      -> *(*(score_3D[2] + i))
//                           : &score_3D[2][0][0]값을 저장한 주소값에 i만큼(이 경우는 1차원의 행에로 해당하는 배열크기만큼 영역을 움직임)의 주소값을 더해서 이를 역참조한 값(= 얘도 주소값)을 역참조한 score_3D[2][i][0]값

#include<stdio.h>
int main() {

    // 3차원 배열 score_3D
    int score_3D[5][5][5] = { 0 };

    // pScore1 = score_3D = &score_3D[0][0][0]       <- score_3D 단독은  score_3D[0][0][0]의 주소값과 아무런 연관이 없는 쓰레기 주소값 가짐
    int* pScore1 = score_3D;                         // 포인터변수에 대입했을 경우 score_3D = &score_3D[0][0][0]로 인식... 

    // pScore2 = score_3D[2] = &score_3D[2][0][0]    <- score_3D[2] 단독은 2중 포인터변수로 score_3D[2] = score_3D[2][0] = &score_3D[2][0][0] , *score_3D[2] = *score_3D[2][0] = score_3D[2][0][0]
    int* pScore2 = score_3D[2];                      // 포인터변수에 대입했을 경우 score_3D[2] = &score_3D[2][0][0]로 인식... 

    // pScore3 = score_3D[3][4] = &score_3D[3][4][0]
    int* pScore3 = score_3D[3][4];

    int key = 0;

    // 3차원 배열 채우기
    for (int i = 0; i < 5; i++) {

        for (int j = 0; j < 5; j++) {

            for (int u = 0; u < 5; u++) {

                key += 2;
                score_3D[i][j][u] = key;
                printf("%3d ", score_3D[i][j][u]);
            }

            // 1차원이 끝날때마다 |로 표기
            printf(" | ");
        }
        // 2차원이 끝날때마다 줄 바꿈
        printf("\n");
    }

    printf("\n");

    // 원칙적으로 pScore1 = score_3D = &score_3D[0][0][0]를 의미함을 확인 (포인터변수에 대입하지 않은 score_3D = score_3D[0][0][0]의 주소값과 아무런 연관이 없음..)
    for (int i = 0; i < 5; i++) {

        printf("%3d ", *(pScore1 + i));
        printf("%3d ", *(&score_3D[0][0][0] + i));

        // (중요) C언어는 포인트변수 없이 단독으로 쓴 3차원배열변수 score_3D의 경우를 score_3D[0][0][0]와 아무런 연관이 없는 주소값으로 판정
        // printf("%3d ", *(score_3D + i));           
        // printf("%3d ", **(score_3D + i));

        printf(" | ");

    }

    printf("\n\n");

    // 원칙적으로 pScore2 = score_3D[2] = &score_3D[2][0][0]를 확인 (포인터변수에 대입하지 않은 score_3D[2] = 2중포인터변수로 해석..)
    for (int i = 0; i < 5; i++) {

        printf("%3d ", *(pScore2 + i));
        printf("%3d ", *(&score_3D[2][0][0] + i));

        //컴파일러에 따라 score_3D[2] 단독은 진짜 3차원배열변수[2][0][0]의 주소값을 저장하는 2중 포인터변수로 해석되기도 함
        printf("%3d ", *(*score_3D[2] + i));        


        printf(" | ");

    }

    printf("\n");

    // *(*score_3D[2] + i) != *(score_3D[2] + i) != *(*(score_3D[2] + i) 를 의미함을 확인
    for (int i = 0; i < 5; i++) {

        // 컴파일러에 따라 score_3D[2] 단독은 진짜 3차원배열변수[2][0][0]의 주소값을 저장하는 2중 포인터변수로 해석되기도 함
        printf("%3d ", *(*score_3D[2] + i));        // score_3D[2][0][i]값 : 102 104 106 108 110

        // // 정황상 C언어는 score_3D[2]를 score_3D[2][0][0]의 주소값을 담은 2중 포인터변수로 두는것이 포착
        printf("%3d ", *(score_3D[2] + i));         // 포인터값이 나옴

        //  *(*score_3D[2] + i));와 비슷해 보이지만, *score_3D[2] + i와 *(score_3D[2] + i)의 ()를 씌었냐의 차이로 해석이 180도 달라짐
        printf("%3d ", *(*(score_3D[2] + i)));      // score_3D[2][i][0]값 : 102 112 122 132 142

        printf(" | ");

    }

    printf("\n\n");

    // pScore3 = score_3D[3][4] = &score_3D[3][4][0]를 의미함을 확인
    for (int i = 0; i < 5; i++) {

        printf("%3d ", *(pScore3 + i));
        printf("%3d ", *(score_3D[3][4] + i));
        printf(" | ");
    }

    return 0;
}
