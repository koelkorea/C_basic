#include <stdio.h>

// 포인터
//  : 어떤 '자료형을 가진 변수'가 메모리상에 위치하는 주소값을 저장하여 가리키는 자료형
//     -> 이를 각 자료형 타입에 해당하는 방식으로 역참조하여 값이 얼마인지 참조도 가능함..
//        (= 포인터 자료형은 포인터 이외의 원시형, class, struct 등의 자료형의 종류만큼이나 그 종류가 다양함)

//   # (중요) 포인터를 사용하는 목적
//      : 변수가 저장된 메모리 주소에 접근하는 수단 -> 그 주소에 위치하는 값을 읽고, 쓰기위한 역참조가 목적
// 
//        ex) *pA    <- pA의 값(시작 주소) + 자료형 크기만큼 메모리 접근하여 값을 추출함
     
//   # (중요) 포인터 변수의 메모리 할당 크기 
//   	: 운영체제의 비트수에 따라 다르다고 함 (보통 64비트는 8byte로 쓰인다고 함)
//         -> 이해하기 어려우면, 운영체제의 비트수에 따라 주소명을 적는 판의 크기가 다르게 규정된다고 생각하면 될 듯
//              -> 포인터 변수도 일종의 고유적인 자료형이라 생각하고, 고유의 할당크기가 있다고 보자


//  - 포인터 변수 선언법 ( asterisk(*) 연산자 사용)
//     : 자료형 * 포인터변수명          <- 특정 자료형의 주소값을 저장 할 수 있는 포인터 변수 선언
       
//        ex) int* score;               <- int 자료형의 주소를 저장하는 포인터 변수인 score를 선언 
//              -> int * 의미
//                  : 변수 a의 시작주소값을 저장... 이를 역참조시 + sizeof(int) 까지의 주소값에 해당하는 부분을 읽어 값을 찾게 함


//  - 포인터 변수 초기화 ( ampersand(&)연산자 사용)
//      : 포인터변수명 = &변수;		
//  
//         ex) int * score = &a;         <- int 자료형의 주소를 저장하는 포인터 변수인 score에 a변수의 주소값을 저장함
    
//       # (주의) 포인터 변수를 초기화 해야할시 선언된 포인터 변수의 자료 타입이 같아야 한다는 점 명심해야 함
//           -> 정확히는 메모리 할당된 크기가 다른데, 포인터변수는 찾아온 주소값을 역참조할때 그 자료형의 메모리 크기랑 형식을 고려해서 값을 가져오기 때문
    
//               ex) int * score = &a; double a = 123123123.01; 같은건 성립이 힘듦	


//  - (중요) array to pointer decay (상수 포인터)
//      : 배열로 선언된 변수 a는 그 자체가 a[0]의 주소를 의미하며, &가 필요없다
//          -> 정확히는 pointer 변수의 값에 배열변수 a를 넣으면, 그 크기정보가 부식(decay) 되고, 시작 주소값만 남게 된다는 개념 

//       # 2차원 배열로 선언된 변수 a는 1차원에 해당하는 부분을 의미하는 변수의 표기값 그 자체가 주소를 의미하며, &가 필요없다 (n차원 배열도 메모리 할당은 선형성을 띄는 연속적 할당이기 때문)
//          -> (중요!) But! 3차원 이상이 될 경우, 'array_2d[5]' 이런 형식만으로는 주소값으로 인식되지 않음 
//              -> 3차원 이상의 배열의 포인터들을 다루기 위한 다차원 포인터 배열을 위한 전용 형식이 필요 
//                 (이를 위해서는 다중 포인터 개념(day12-4.c로...)이 선행되어야 하며, 다차원 배열과 포인터와 관련된 내용을 배워야함 (day14-6.c로..) )
            
//                  ex) int array_2d[5][5] = {0};
//                      int* pointer_array1[5] = { array_3d[0] , array_3d[1] , array_3d[2] , array_3d[3] , array_3d[4] };		<- 이런식으로 표기가 가능하며
//                      int* pin_point = array_3d[2];		                                                                    <- 이런거도 성립


//  - 역참조 = 간접접근(Indirect Access)
//     : 해당 포인터변수가 저장한 변수의 주소가 가진 원래 값을 알아보는것
    
//      # 역참조 형식
//         : *(선언된) 포인터변수명          <-  포인터의 시작 주소 + 자료형 크기로 메모리 읽기 
        
//           ex) int* score = &a;            <- 포인터변수 score가 위치한 주소값 : 0x11111, score에 저장된 int 주소값 : 0x222222 (변수 a의 주소)			
//               int a = 1;                  <- 변수a 주소 : 0x222222, 변수a값 : 1
//           	 *score = 1;                 <- 포인터변수 score를 역참조한 값 (= 변수 a의 값)
	      
//      # (중요) 결론 : *는 선언 이후 일반적으로는 안 쓰고, 역참조 할때만 쓴다!
//         1. *score = a    ->  *score를 변경 = a를 변경 (저장한 변수의 값을 가리키고 변경하기 때문)
//         2. score = &a    -> 포인터변수가 선언된 이후에 저장한 주소를 보고 싶으면, *는 쓰지 않는다
        
//      # *(asterisk)연산자 사용 종류
//         1. 곱셈 연산자         : 변수 * 변수
//         2. 포인터 변수 선언    : 자료형 * 포인터변수명
//         3. 간접접근(= 역참조)  : *(선언된)포인터변수명
    
    
//  - 포인터 연산

//  	# 포인터 4칙 연산의 case
//  	   1. 포인터 변수의 주소값 그 자체에 다른 변수간의 연산	   
//  	   	  ex) 포인터변수 + 정수 = 포인터변수 + 정수 * 포인터변수의 자료형 크기
    	   
//  	   2. 포인터 변수의 역참조 값과 다른 변수를 계산하는 경우		   
//  	   	   ex) *포인터변수 + 실수 or 정수
    	   
//  	   3. 포인터변수와 포인터변수의 비교 및 빼기 연산 (하단의 3번 참고)
//  	   	   -> (중요) 부등호, 뺴기만 가능
    

//  	# 포인터 4칙 연산의 기본 조건
//         : 같은 자료형을 갖는 포인터만 대입이 가능 + 주소의 위치를 기반으로 값을 가지고 목적상 메모리의 위치를 찾는거라 생각하면.. 포인터끼리의 덧셈, 곱셈은 불가능하다는 것이 이해됨
    
//            1. 같은 형을 갖는 포인터는 대입 가능

//               ex) int a = 10, b = 20;		
//                   int* ip1 = &a, ip2 = &b;
//                   ip1 = ip2;                 <- 덮어씌우기
              
//            2. 포인터 변수를 정수로 더하거나 빼기 가능
//                -> 해당 주소값 뒤에 의치한 주소값을 찾는 경우

//               ex) ip1 + 1 (해당 포인터가 가르키는 주고값의 바로 다음 주소값);
              
//            3. 같은 배열을 가리키는 포인터의 빼기와 비교 가능(덧셈 불가)
//                -> 주소의 위치값도 값이라 비교 연산 가능
         
//               ex) int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; 
//            	     int* ip1  = &a[2], ip2 = &a[8]; 
//            	     ip2 - ip1 (빼기 가능) = ip2 > ip1(비교 가능)			<- (중요) 덧셈은 불가능
              
//            4. 0(NULL)과 비교 또는 0의 대입 가능	=> 포인터 변수의 안전한 초기화가 가능

//            	 ex) ip1 = 0; ip2 = NULL;
              
//            5. 이외 모든 연산은 불가!

#include <stdio.h>

int main() {
	int a = 365;
	char c = 'A';

	// 포인터변수 선언 예시
	int* p = &a;    // 포인터변수 *p는 int형인 변수 a의 주소값를 담음,
	char* pc = &c;  // 포인터변수 *pc는 char형인 변수 c의 주소값를 담음,

	// * p == a  , p == &a
	// * pc == c  , pc == &c

	// 간접접근(Indirect Access) 예시1
	//  : 해당 포인터변수가 저장한 변수의 주소가 가진 원래 값을 알아보는것
	printf(" a 데이터 : %d \n", a);     // a 데이터 : 365
	printf("*p 데이터 : %d \n\n", *p);  // *p 데이터 : 365
	
	// 간접접근(Indirect Access) 예시2
	//  : 해당 포인터변수가 저장한 변수의 주소가 가진 원래 값을 알아보는것
	printf("  c 데이터 : %d \n", c);         // c 데이터 : 65
	printf("*pc 데이터 : %d \n\n", *pc);     // c 데이터 : 65

	// 역참조(간접접근)한 값 = 해당 포인터 변수에 저장된 주소의 변수가 값
	//  -> 역참조값 변경 = 해당 포인터 변수에 저장된 주소의 변수가 값에도 변동
	*p = *p + 10;       // int 변수a의 값을 간접접근   : 365 + 10
	*pc = *pc + 10;		// char 변수c의 값을 간접접근 : 65 + 10

	// (중요) *는 포인터변수 선언 이후 역참조 할때만 쓴다!
	// * p == a 
	printf(" a 데이터 : %d \n", a);       // a 데이터  : 375
	printf("*p 데이터 : %d \n\n", *p);    // *p 데이터 : 375

	// * pc == c 
	printf("  c 데이터 : %d \n", c);      // c 데이터 : 75
	printf("*pc 데이터 : %d \n\n", *pc);  // *pc 데이터 : 75

	// (중요) *는 선언 이후 일반적으로는 안 쓰고, 역참조 할때만 쓴다!
	// p == &a
	printf(" &a 주소 : %p \n", &a);	      // &a 주소 : 000000E98296F9D4
	printf("  p   값 : %p \n", p);        // p 주소 : 000000E98296F9D4

	// 포인터 변수 p도 자신이 위치한 주소는 존재 (단 a의 주소랑은 다르다)
	printf(" &p 주소 : %p \n\n", &p);     //  &p 주소 : 00000092D58FF6D8

	// pc == &c
	printf(" &c 주소 : %p \n", &c);       // &c 주소 : 000000E98296F9F4
	printf(" pc   값 : %p \n", pc);       // pc 주소 : 000000E98296F9F4

	// 포인터 변수 p도 자신이 위치한 주소는 존재 (단 a의 주소랑은 다르다)
	printf("&pc 주소 : %p \n\n", &pc);    // &pc 주소 : 00000092D58FF6F8


	printf("--------------------------------------------------------------------------------------- \n\n");
	printf("포인터 선언시 자료형이 안 맞는 경우 \n");

	int d = 9;
	int f = 999;
	char g = 'Z';

	// 포인터변수 자료형 선언이 잘못된 예시
	char* pd = &d;     // 포인터변수 *pc는 char형인 변수 c의 주소값를 담음,
	char* pf = &f;     // 포인터변수 *pf는 char형인 변수 c의 주소값를 담음,
	int* pg = &g;      // 포인터변수 *pg는 int형인 변수 a의 주소값를 담음,

	//\ 간접접근(Indirect Access)의 자료형 안 맞는 케이스1
	//  : char 포인터변수의 자료형 메모리 크기 = 참고하는 int 변수가의 메모리 실점유 크기
	//      -> 이 경우는 포인터 변수가 int변수가 위치한 주소를 전부 저장하기에는 턱없이 부족하지만, 실제로 해당 int 변수가 표기한 값을 알아내는데는 문제가 없으므로 글자가 안 깨짐 
	//         (int로 저장한 9나 char로 저장한 9나 같은 방식으로 메모리를 사용)
	printf(" d 데이터 : %d \n", d);           //    d 데이터 : 9
	printf("*pd 데이터 : %d \n\n", *pd);      //  *pd 데이터 : 9

	// 간접접근(Indirect Access)의 자료형 안 맞는 케이스2
	//  : char 포인터변수의 자료형 메모리 크기 < 참고하는 int 변수가의 메모리 실점유 크기
	//     -> 이 경우는 포인터 변수가 int변수가 위치한 주소를 전부 저장하기에는 턱없이 부족하기에, 실제 int값이 저장된 메모리의 일부만 읽어온 값을 보여줌
	printf(" f 데이터 : %d \n", f);          //	  f 데이터 : 999
	printf("*pf 데이터 : %d \n\n", *pf);     // *pf 데이터 : -25

	// 간접접근(Indirect Access)의 자료형 안 맞는 케이스3
	//  : int 포인터변수의 자료형 메모리 크기 > 참고하는 char 변수가의 메모리 실점유 크기
	//     -> 이 경우는 포인터 변수는 실제 char 변수가 위치한 메모리 주소 외, 나머지 3btye의 아무값도 지정되지 않은 메모리 영역까지 강제로 읽어와서 알수 없는 값이 출력
	printf("  g 데이터 : %d \n", g);         //   g 데이터 : 90
	printf("*pg 데이터 : %d \n\n", *pg);	 // *pg 데이터 : -858993574

	return 0;
}
