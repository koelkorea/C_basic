#include <stdio.h>

// 포인터 : 메모리 주소를 저장하여 가리키는 변수

//		# (중요) 포인터를 사용하는 목적
//			: 메모리 주소를 접근하는 수단 -> 그 주소에 위치하는 값을 읽고, 쓰기위한 역참조가 목적
//		      ex) *pA : pA의 값(시작 주소) + 자료형 크기만큼 메모리 접근하여 값을 추출함


//		# (중요) 포인터 변수의 메모리 할당 크기 
//			: 운영체제의 비트수에 따라 다르다고 함 (보통 64비트는 8byte로 쓰인다고 함)
//				-> 이해하기 어려우면, 운영체제의 비트수에 따라 주소명을 적는 판의 크기가 다르게 규정된다고 생각하면 될 듯
//					(포인터 변수도 일종의 고유적인 자료형이라 생각하고, 고유의 할당크기가 있다고 보자)

//	- 포인터 변수 선언법 ( asterisk(*) 연산자 사용)
//		: 자료형 * 포인터변수명	<= 특정 자료형의 주소를 저장 할 수 있는 포인터 변수 선언
//			ex) int* score;			<- int 자료형의 주소를 저장하는 포인터 변수인 score를 선언

//	- 포인터 변수 초기화 ( ampersand(&)연산자 사용)
//		: 포인터변수명 = &변수;		
//			ex) int * score = &a;			<- int 자료형의 주소를 저장하는 포인터 변수인 score에 a변수의 주소값을 저장함

//		# (주의) 포인터 변수를 초기화 해야할시 선언된 포인터 변수의 자료 타입이 같아야 한다는 점 명심해야 함
//			ex)  int * score = &a; double a = 123123123.01; 같은건 성립이 힘듦	(정확히는 메모리 할당된 크기의 문제 때문이다)
// 
//       # (중요)  array to pointer decay (상수 포인터)
//              : 배열로 선언된 변수 a는 그 자체가a[0]의 주소를 의미하며, &가 필요없다
//						-> 정확히는 pointer 변수의 값에 배열변수 a를 넣으면, 그 크기정보가 부식(decay) 되고, 시작 주소값만 남게 된다는 개념 

//	- 역참조 = 간접접근(Indirect Access) : 해당 포인터변수가 저장한 변수의 주소가 가진 원래 값을 알아보는것
//		: *(선언된)포인터변수명				<-  포인터의 시작 주소 + 자료형 크기로 메모리 읽기 
//			ex) int * score = &a;	 int a = 1		<- int * (변수 a 시작 주소 + sizeof(int))
//				 - 포인터변수 *score 주소 : 0x11111, 값 : 0x222222 (변수 a의 주소)			 -  변수 a	주소 : 0x222222, 값 : 1
//					-> 이 경우 score = 0x222222(변수 a의 주소값)			* score = 1 (변수 a의 값)

//		# (중요) 결론 : *는 선언 이후 일반적으로는 안 쓰고, 역참조 할때만 쓴다!
//			1. *score = a   ->  *score를 변경 = a를 변경 (저장한 변수의 값을 가리키고 변경하기 때문)
//			2. score = &a	 -> 포인터변수가 선언된 이후에 저장한 주소를 보고 싶으면, *는 쓰지 않는다

//		# *(asterisk)연산자 사용 종류
//			1. 곱셈 연산자  : 변수 * 변수
//			2. 포인터 변수 선언 : 자료형 * 포인터변수명
//			3. 간접접근  : *(선언된)포인터변수명

//	- 포인터 연산 종류
//		1. 포인터 변수의 주소값 그 자체에 다른 변수간의 연산
//			ex) 포인터변수 + 정수 = 포인터변수 + 정수 * 포인터변수의 자료형 크기

//		2. 포인터 변수의 역참조 값과 다른 변수를 계산하는 경우
//			ex) *포인터변수 + 실수 or 정수

//		3. 포인터변수와 포인터변수의 비교 및 빼기 연산 (하단의 3번 참고)
//			-> (중요) 부등호, 뺴기만 가능

//		#포인터 연산의 기본 조건: 같은 자료형을 갖는 포인터만 대입이 가능하다는거... 

//			1. 같은 형을 갖는 포인터는 대입 가능
//				ex) int a = 10, b = 20;		->		int* ip1 = &a, * ip2 = &b;		->		ip1 = ip2;

//			2. 포인터 변수를 정수로 더하거나 빼기 가능
//				ex) ip1 + 1	(* 자료형 크기 주소);

//			3. 같은 배열을 가리키는 포인터의 빼기와 비교 가능(덧셈 불가)	: 
//				ex)	int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; 
//						int* ip1 = &a[2], * ip2 = &a[8]; 
//						ip2 - ip1 (빼기 가능)		=		ip2 > ip1(비교 가능)			<- (중요) 덧셈은 불가능

//			4. 0(NULL)과 비교 또는 0의 대입 가능	=> 포인터 변수의 안전한 초기화가 가능
//				ex) ip1 = 0; ip2 = NULL;

//			5. 이외 모든 연산은 불가!

#include <stdio.h>

int main() {
	int a = 365;
	char c = 'A';

	// 포인터변수 선언 예시
	int* p = &a;		// 포인터변수 *p는 int형인 변수 a의 주소값를 담음,
	char* pc = &c;	// 포인터변수 *pc는 char형인 변수 c의 주소값를 담음,

	// * p == a  , p == &a
	// * pc == c  , pc == &c

	// 간접접근(Indirect Access) 예시1 : 해당 포인터변수가 저장한 변수의 주소가 가진 원래 값을 알아보는것
	printf(" a 데이터 : %d \n", a);			 //	a 데이터 : 365
	printf("*p 데이터 : %d \n\n", *p);	//  *p 데이터 : 365
	
	// 간접접근(Indirect Access) 예시2 : 해당 포인터변수가 저장한 변수의 주소가 가진 원래 값을 알아보는것
	printf("  c 데이터 : %d \n", c);			// c 데이터 : 65
	printf("*pc 데이터 : %d \n\n", *pc);	// c 데이터 : 65

	// 역참조(간접접근)한 값 = 해당 포인터 변수에 저장된 주소의 변수가 값
	//		-> 역참조값 변경 = 해당 포인터 변수에 저장된 주소의 변수가 값에도 변동
	*p = *p + 10;			// int 변수a의 값을 간접접근 : 365 + 10
	*pc = *pc + 10;		// char 변수c의 값을 간접접근 : 65 + 10

	//	(중요) *는 포인터변수 선언 이후 역참조 할때만 쓴다!
	// * p == a 
	printf(" a 데이터 : %d \n", a);			// a 데이터 : 375
	printf("*p 데이터 : %d \n\n", *p);	// *p 데이터 : 375

	// * pc == c 
	printf("  c 데이터 : %d \n", c);				// c 데이터 : 75
	printf("*pc 데이터 : %d \n\n", *pc);	// *pc 데이터 : 75

	//	(중요) *는 선언 이후 일반적으로는 안 쓰고, 역참조 할때만 쓴다!
	// p == &a
	printf(" &a 주소 : %p \n", &a);		// &a 주소 : 000000E98296F9D4
	printf("  p   값 : %p \n", p);				// p 주소 : 000000E98296F9D4

	// 포인터 변수 p도 자신이 위치한 주소는 존재 (단 a의 주소랑은 다르다)
	printf(" &p 주소 : %p \n\n", &p);		//  &p 주소 : 00000092D58FF6D8

	// pc == &c
	printf(" &c 주소 : %p \n", &c);		// &c 주소 : 000000E98296F9F4
	printf(" pc   값 : %p \n", pc);			// pc 주소 : 000000E98296F9F4

	// 포인터 변수 p도 자신이 위치한 주소는 존재 (단 a의 주소랑은 다르다)
	printf("&pc 주소 : %p \n\n", &pc);		// &pc 주소 : 00000092D58FF6F8


	printf("--------------------------------------------------------------------------------------- \n\n");
	printf("포인터 선언시 자료형이 안 맞는 경우 \n");

	int d = 9;
	int f = 999;
	char g = 'Z';

	// 포인터변수 자료형 선언이 잘못된 예시
	char* pd = &d;	// 포인터변수 *pc는 char형인 변수 c의 주소값를 담음,
	char* pf = &f;	// 포인터변수 *pf는 char형인 변수 c의 주소값를 담음,
	int* pg = &g;		// 포인터변수 *pg는 int형인 변수 a의 주소값를 담음,

	// 간접접근(Indirect Access)의 자료형 안 맞는 케이스1
	//		: char 포인터변수의 자료형 메모리 크기 = 참고하는 int 변수가의 메모리 실점유 크기
	//			-> 이 경우는 포인터 변수가 int변수가 위치한 주소를 전부 저장하기에는 턱없이 부족하지만, 실제로 해당 int 변수가 표기한 값을 알아내는데는 문제가 없으므로 글자가 안 깨짐 
	//				(int로 저장한 9나 char로 저장한 9나 같은 방식으로 메모리를 사용)
	printf(" d 데이터 : %d \n", d);				//	d데이터 : 9
	printf("*pd 데이터 : %d \n\n", *pd);	//  *pd 데이터 : 9

	// 간접접근(Indirect Access)의 자료형 안 맞는 케이스2
	//		: char 포인터변수의 자료형 메모리 크기 < 참고하는 int 변수가의 메모리 실점유 크기
	//			-> 이 경우는 포인터 변수가 int변수가 위치한 주소를 전부 저장하기에는 턱없이 부족하기에, 실제 int값이 저장된 메모리의 일부만 읽어온 값을 보여줌
	printf(" f 데이터 : %d \n", f);				//	f 데이터 : 999
	printf("*pf 데이터 : %d \n\n", *pf);	//  *pf 데이터 : -25

	// 간접접근(Indirect Access)의 자료형 안 맞는 케이스3
	//		: int 포인터변수의 자료형 메모리 크기 > 참고하는 char 변수가의 메모리 실점유 크기
	//			-> 이 경우는 포인터 변수는 실제 char 변수가 위치한 메모리 주소 외, 나머지 3btye의 아무값도 지정되지 않은 메모리 영역까지 강제로 읽어와서 알수 없는 값이 출력
	printf("  g 데이터 : %d \n", g);				// g 데이터 : 90
	printf("*pg 데이터 : %d \n\n", *pg);	// *pg 데이터 : -858993574

	return 0;
}
