//   array to pointer decay (상수 포인터)
//		: 배열로 선언된 변수 a는 그 자체가 a[0]의 주소를 의미하며, &가 필요없다
//			-> 정확히는 pointer 변수의 값에 배열변수 a를 넣으면, 그 크기정보가 부식(decay) 되고, 시작 주소값만 남게 된다는 개념 

//      # (결론) 배열도 일종의 포인터 (상수 포인터)    =  다른 한편으로는 포인터도 배열개념으로 형식에 맞춰 쓸수 있다는 말이 됨
//              -> 문자열도 char 배열로서 pointer array 개념이랑 연관될 수 있음
// 
//                   ex)    포인터식 표현             배열식 표현
//                                  *(p + 3)               =            p[3]                : 둘 다 의미는 포인터변수 p의 현재 주소값에서 (해당 자료형 메모리크기 * 3) 만큼 높은 메모리 주소를 의미  
//                                                                                                          -> 포인터변수라도 배열식으로 쓰면 기본적으로 주소값이 아닌 일반 값을 참조 (그냥 배열처럼 쓰면 배열같이 생각하자)

// ex)	int a[5] = { 1,2,3,4,5 };
//         int *p=a; 라면,
//         (중요) a = &a[0] 유추 가능 
// 
//          1) a는 상수 포인터
//          2) a는 int 자료형 타입 집합의 시작주소 위치
//                  -> *(a + 2) == a[2]
//                  -> a + 2 == &a[2] 

//      # (중요) p = &a[0]로 고정시, 배열 a와 포인터 p의 관계 정리
            /* ------------------------------------- [메모리 주소값]------------------------------------  ===============[역참조값 = 배열값]===============
                |   & a[0]    =      a             =     & p[0]       =      p             =    0x7ffffb0ee620     |   	 1     =   a[0]    =      * a   	            =       p[0]     =    * p           |
                |   & a[1]    =      a + 1       =     & p[1]	     =       p + 1      =    0x7ffffb0ee624     |   2	    =   a[1]     =      * (a + 1)     	=       p[1]     =    * (p + 1)  |
                |   & a[2]    =      a + 2       =     & p[2]	     =       p + 2      =    0x7ffffb0ee628     |   3	    =   a[2]     =      * (a + 2)     	=       p[2]     =    * (p + 2)  |
                |   & a[3]    =      a + 3       =     & p[3]	     =       p + 3      =    0x7ffffb0ee62C     |   4   	=   a[3]     =      * (a + 3)     	=       p[3]     =    * (p + 3)  |
                |   & a[4]    =      a + 4       =     & p[4]	     =       p + 4      =    0x7ffffb0ee632     |   5	    =   a[4]     =      * (a + 4)     	=       p[4]     =    * (p + 4)  | */

// 포인터와 역참조 값의 전, 후위 연산자
//     : (중요) 주소값 계산과 실제 배열의 값의 구별을 하고, 배열값에는 전,후위 계산을 정확히 하자
#include <stdio.h>
int main()
{
    int a[] = { 10, 20, 30, 40, 50, 60 };
    int i;

    int* ptr = a;       //  ptr = &a[0]

    //----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     // [CASE 1] 포인터변수 자체에 전, 후위 연사자를 끼얹기 = 주소값 계산에만 전,후위 연산자 끼얹기
    printf("-------------------------------------------------------------------");

    // ex1) 후위연산자를 통한 ptr++을 통한 ptr 역참조값
    for (i = 0; i < 5; i++) {
        printf("%d ", *(ptr++));            //  10, 20, 30, 40, 50
    }
    
    // 포인터 변수값 원상복구
    printf("\n");
    ptr = a;

    // ex2) 전위연산자를 통한 ptr++을 통한 ptr 역참조값
    for (i = 0; i < 5; i++) {
        printf("%d ", *(++ptr));            // 20, 30, 40, 50, 60
    }

     // 포인터 변수값 원상복구
    printf("\n");
    ptr = a;

    //----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    //  [CASE 2] 포인터변수 자체와 역참조 값에도 전, 후위 연사자를 끼얹기 = 주소값 계산과 역참조 값 그 자체에도 전,후위 연산자 끼얹기
     //     : (중요) 주소값 계산과 실제 배열의 값의 구별을 하고, 배열값에는 전,후위 계산을 정확히 하자
    printf("-------------------------------------------------------------------");

    // ex1) 역참조값에 전위연산자 + 포인터값에 후위연산자를 통한 연산
    for (i = 0; i < 5; i++) {

        // ++ *(ptr++) = ++a[i]과 같은 형태
        printf("%d ", ++ * (ptr++));         //  11, 21, 31, 41, 51             <- 역참조 값은 전위연산자로 계산되었기에 +1 반영 (포인터쪽은 초기화가 끝나서 전혀 문제 없음)
    }

     // 포인터 변수값 원상복구
    printf("\n");
    ptr = a;

    //  ex2) 역참조값에 후위연산자 + 포인터값에 후위연산자를 통한 연산 
    for (i = 0; i < 5; i++) {

        // *(ptr++)++ = a[i]++와 같은 형태
        printf("%d ", (*(ptr++))++);        //  11, 21, 31, 41, 51               <- 역참조 값은 후위연산자로 계산되었기에 당장 +1 반영은 X (포인터쪽은 초기화가 끝나서 전혀 문제 없음)
    }

    printf("\n");

    //오리지날 배열 a의 요소값
    for (i = 0; i < 6; i++) {
        printf("%d ", a[i]);                        //  12 22 32 42 52 60            <- ex2) 에서 후위연산자로 계산된 +1 반영
    }

    printf("\n");

    return 0;
}
