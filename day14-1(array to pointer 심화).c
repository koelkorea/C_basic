// array to pointer decay (상수 포인터)
//  : 배열로 선언된 변수 a는 그 자체가 a[0]의 주소를 의미하며, &가 필요없다
//      -> 정확히는 pointer 변수의 값에 배열변수 a를 넣으면, 그 크기정보가 부식(decay) 되고, 시작 주소값만 남게 된다는 개념 
//          -> (중요!) 배열로 변언된 변수 스스로의 이름은 포인터라는 말

//      # (중요!) array변수의 이중성
//          - array변수 자신 : 포인터변수 (array자신의 시작주소값을 의미)
//          - []와 함께 경우 : 배열 안에 위치하는 단순 자료형 변수 (= 포인터와 관련성이 1도 없음)

//      # (결론) 배열도 일종의 포인터 (상수 포인터)  = 다른 한편으로는 포인터도 배열개념으로 형식에 맞춰 쓸수 있다는 말이 됨
//          -> 문자열도 char 배열로서 pointer array 개념이랑 연관될 수 있음
 
//              ex) 포인터식 표현      배열식 표현   : 둘 다 의미는 포인터변수 p의 현재 주소값에서 (해당 자료형 메모리크기 * 3) 만큼 높은 메모리 주소를 의미  
//                    *(p + 3)    =      p[3]         -> 포인터변수라도 배열식으로 쓰면 기본적으로 주소값이 아닌 일반 값을 참조 (그냥 배열처럼 쓰면 배열같이 생각하자) 

                                         
// ex)	int a[5] = { 1,2,3,4,5 };
//         int *p=a; 라면,
//         (중요) a = &a[0] 유추 가능 
// 
//          1) a는 상수 포인터
//          2) a는 int 자료형 타입 집합의 시작주소 위치
//                  -> *(a + 2) == a[2]
//                  -> a + 2 == &a[2] 

//      # (중요) p = &a[0]로 고정시, 배열 a와 포인터 p의 관계 정리
            /* ------------------------------------- [메모리 주소값]------------------------------------  ===============[역참조값 = 배열값]===============
                |   & a[0]    =      a           =     & p[0]        =       p          =    0x7ffffb0ee620     |   1        =   a[0]    =      * a   	        =       p[0]     =    * p        |    
                |   & a[1]    =      a + 1       =     & p[1]	     =       p + 1      =    0x7ffffb0ee624     |   2	    =   a[1]     =      * (a + 1)     	=       p[1]     =    * (p + 1)  |    
                |   & a[2]    =      a + 2       =     & p[2]	     =       p + 2      =    0x7ffffb0ee628     |   3	    =   a[2]     =      * (a + 2)     	=       p[2]     =    * (p + 2)  |    
                |   & a[3]    =      a + 3       =     & p[3]	     =       p + 3      =    0x7ffffb0ee62C     |   4   	=   a[3]     =      * (a + 3)     	=       p[3]     =    * (p + 3)  |    
                |   & a[4]    =      a + 4       =     & p[4]	     =       p + 4      =    0x7ffffb0ee632     |   5	    =   a[4]     =      * (a + 4)     	=       p[4]     =    * (p + 4)  |    

               ---------------------------- [역참조값 = 배열값]---------------------------
               |     1      =       a[0]        =        *a           =      p[0]        =   *p        | 
               |     2      =       a[1]        =        *(a + 1)     =      p[1]        =    *(p + 1) |
               |     3      =       a[2]        =        *(a + 2)     =      p[2]        =    *(p + 2) |
               |     4      =       a[3]        =        *(a + 3)     =      p[3]        =    *(p + 3) |
               |     5      =       a[4]        =        *(a + 4)     =      p[4]        =    *(p + 4) | */

#include <stdio.h>
int main()
{
    int* p, a[5] = { 10, 20, 30, 40, 50 };

    //배열 이름은 배열의 시작주소 값이다.
    p = a;  // p = &a[0] 와 같은 의미

    printf("1. %p\n", a);                    //  000000B63D5BF5F8
    printf("2. %d\n", *p);                 // 10
    printf("3. %d\n", *(p + 1));        // 20
    printf("4. %d\n", p[2]);               // 30
    printf("5. %d\n\n", *(a + 3));     // 40

    // p의 주소값 자체가 변경 (후위 연산자)
    p += 1; // p = p + 1    
    //a += 2; 배열 이름은 상수 포인터로 변경 불가능

    printf("6. %p\n", p);                  // 000000B63D5BF5FC  = 000000B63D5BF5F8 + 4btye      <- 후위 연산자로 인해 p의 주소값이 변경 (1과 6의 메모리 값을 보면 4btye 차이남) 
    printf("7. %d\n", *p);                // 20
    printf("8. %d\n", *(p - 1));        // 10      
    printf("9. %d\n", *(p + 1));       // 30
    printf("10. %d\n", a[3]);           //  40
    printf("11. %d\n", p[3]);           //  40        <- p[3] = p + 3 (현재 p의 메모리 위치 + (3 * 4byte)한 의미와 같다)
    printf("12. %d\n", p[-1]);          //  10
    printf("13. %d\n", *p + 2);        //  12       <- 20 + 2 = 22 

    return 0;
}
