// array to pointer decay (상수 포인터)
//  : 배열로 선언된 변수 a는 그 자체가 a[0]의 주소를 의미하며, &가 필요없다
//      -> 정확히는 pointer 변수의 값에 배열변수 a를 넣으면, 그 크기정보가 부식(decay) 되고, 시작 주소값만 남게 된다는 개념 
//          -> (중요!) 배열로 변언된 변수 스스로의 이름은 포인터라는 말

//      # (중요!) 1차원 array변수의 이중성
//          - array변수 자신 : 포인터변수 (array자신의 시작주소값을 의미)
//          - []와 함께 경우 : 배열 안에 위치하는 단순 자료형 변수 (= 포인터와 관련성이 1도 없음)

//      # (결론) 배열도 일종의 포인터 (상수 포인터)  = 다른 한편으로는 포인터도 배열개념으로 형식에 맞춰 쓸수 있다는 말이 됨
//          -> 문자열도 char 배열로서 pointer array 개념이랑 연관될 수 있음
 
//              ex) 포인터식 표현      배열식 표현   : 둘 다 의미는 포인터변수 p의 현재 주소값에서 (해당 자료형 메모리크기 * 3) 만큼 높은 메모리 주소를 의미  
//                    *(p + 3)    =      p[3]         -> 포인터변수라도 배열식으로 쓰면 기본적으로 주소값이 아닌 일반 값을 참조 (그냥 배열처럼 쓰면 배열같이 생각하자) 

//      # 2차원 배열로 선언된 변수 a는 1차원에 해당하는 부분을 의미하는 변수의 표기값 그 자체가 주소를 의미하며, &가 필요없다 (n차원 배열도 메모리 할당은 선형성을 띄는 연속적 할당이기 때문)
//      	 -> (중요!) But! 3차원 이상이 될 경우, 'array_2d[5]' 이런 형식만으로는 주소값으로 인식되지 않음 
//      		    -> 3차원 이상의 배열의 포인터들을 다루기 위한 다차원 포인터 배열을 위한 전용 형식이 필요 
//      		       (이를 위해서는 다중 포인터 개념(day12-4.c로...)이 선행되어야 하며, 다차원 배열과 포인터와 관련된 내용을 배워야함 (day14-6.c로..) )

//              ex) int array_2d[5][5] = {0};
//                  int* pointer_array1[5] = { array_3d[0] , array_3d[1] , array_3d[2] , array_3d[3] , array_3d[4] };		<- 이런식으로 표기가 가능하며
//                  int* pin_point = array_3d[2];		<- 이런거도 성립

                                             
//              ex)	int a[5] = { 1,2,3,4,5 };
//                  int *p=a; 라면,
//                  (중요) a = &a[0] 유추 가능 

//                   1) a는 상수 포인터
//                   2) a는 int 자료형 타입 집합의 시작주소 위치
//                           -> *(a + 2) == a[2]
//                           -> a + 2 == &a[2] 

//      # (중요) p = &a[0]로 고정시, 배열 a와 포인터 p의 관계 정리
            /*  ------------------------------------ [메모리 주소값]------------------------------------ =============================[역참조값 = 배열값]==========================
                |   & a[0]    =      a           =     & p[0]    =    p        =    0x7ffffb0ee620     |   1     =    a[0]     =     * a          =     p[0]    =    * p        |    
                |   & a[1]    =      a + 1       =     & p[1]    =    p + 1    =    0x7ffffb0ee624     |   2     =    a[1]     =     * (a + 1)    =     p[1]    =    * (p + 1)  |    
                |   & a[2]    =      a + 2       =     & p[2]    =    p + 2    =    0x7ffffb0ee628     |   3     =    a[2]     =     * (a + 2)    =     p[2]    =    * (p + 2)  |    
                |   & a[3]    =      a + 3       =     & p[3]    =    p + 3    =    0x7ffffb0ee62C     |   4     =    a[3]     =     * (a + 3)    =     p[3]    =    * (p + 3)  |    
                |   & a[4]    =      a + 4       =     & p[4]    =    p + 4    =    0x7ffffb0ee632     |   5     =    a[4]     =     * (a + 4)    =     p[4]    =    * (p + 4)  |    

                -------------------------------------[역참조값 = 배열값]----------------------------------
                |     1      =       a[0]        =        *a           =      p[0]        =   *p        | 
                |     2      =       a[1]        =        *(a + 1)     =      p[1]        =    *(p + 1) |
                |     3      =       a[2]        =        *(a + 2)     =      p[2]        =    *(p + 2) |
                |     4      =       a[3]        =        *(a + 3)     =      p[3]        =    *(p + 3) |
                |     5      =       a[4]        =        *(a + 4)     =      p[4]        =    *(p + 4) | */

#include <stdio.h>
int main()
{
    int* p, a[5] = { 10, 20, 30, 40, 50 };

    //배열 이름은 배열의 시작주소 값이다.
    p = a;  // p = &a[0] 와 같은 의미

    printf("1. %p\n", a);              //  000000B63D5BF5F8
    printf("2. %d\n", *p);             // 10
    printf("3. %d\n", *(p + 1));       // 20
    printf("4. %d\n", p[2]);           // 30
    printf("5. %d\n\n", *(a + 3));     // 40

    // p의 주소값 자체가 변경 (후위 연산자)
    p += 1; // p = p + 1    
    //a += 2; 배열 이름은 상수 포인터로 변경 불가능

    printf("6. %p\n", p);              // 000000B63D5BF5FC  = 000000B63D5BF5F8 + 4btye      <- 후위 연산자로 인해 p의 주소값이 변경 (1과 6의 메모리 값을 보면 4btye 차이남) 
    printf("7. %d\n", *p);             // 20
    printf("8. %d\n", *(p - 1));       // 10      
    printf("9. %d\n", *(p + 1));       // 30
    printf("10. %d\n", a[3]);          //  40
    printf("11. %d\n", p[3]);          //  40        <- p[3] = p + 3 (현재 p의 메모리 위치 + (3 * 4byte)한 의미와 같다)
    printf("12. %d\n", p[-1]);         //  10
    printf("13. %d\n", *p + 2);        //  12       <- 20 + 2 = 22 

    return 0;
}
