#include <stdio.h>		

int main() {

	// [연산자]
	// *, +, -,  / , %

	// [관계연산자]
	// > , >= , < , <= , == , != 

	// [논리연산자] 
	// !			: 여집합
	// &&		: 교집합 (A && B면 A가 false면 B는 보지 않는다)
	// ||		: 합집합 (A || B면 A가 true면 B는 보지 않는다

	// [증감연산자] : +-1을 연산하되, 전위 연산자는 전위연산자 턴에 일괄적인 변수 계산을 마친 값을 최종결과값으로 해당 변수에 적용하고, 후위는 해당 코드의 모든 연산이 끝난 후 일괄적으로 변수 계산을 마친 값을 최종결과값으로 해당 변수로 적용
	// - 전위연산자 (++a, --a) : 변수값 a에 1이 더하고 빼짐 (단, 해당 코드의 모든 전위 연산자의 계산은 순차적인게 아니라, 전위턴에 한번에 일괄계산한 값을 적용한다)
	// - 후위연산자 (a++, a--) : 변수값 a에 당장 1이 더하고 빼지지 않고, 연산이 실행되는건 해당 코드의 모든 연산이 끝나고 난 뒤 수행함 (표기되는 연산값이 오리지널 a)
	//		ex) 	c = 9 인데, re = c++ 이면, 코드가 끝난 후 re와 c의 값은??? 
	//				-> re = c;		(코드연산 종료 후) c = c + 1; 로 풀어서 생각하면 간단하다
	//					-> re = 9 , c = 10	: re에 값이 들어가는 시점은 c에 1이 더해지긴 전이다!

	int i = 5, j = 3;
	printf("후위 연산 i = %d, j = %d\n", i++, j++);		//  i = 5, j = 3;
	printf("전위 연산 i = %d, j = %d\n", ++i, ++j);		//  i = 7, j = 5;


	//	[시프트연산자]
	// <<		: 비트값을 왼쪽으로 x만큼 이동 
	//	>>		: 비트값을 오른쪽으로 x만큼 이동

	// [대입연산자]
	//	 =			: 우변의 결과를 좌측변수에 저장 (기존 등호의 의미는 ==)
	// +=, -=, *=, /= , %= ~~~

	// [비트논리연산자]
	// ~			: 비트값의 각 0과 1을 반전 (NOT으로 돌려보면 됨)
	// &			: (두개 이상의 비트값이) 두 비트가 모두1이면 참
	// ^			: (두개 이상의 비트값이) 두 비트가 모두 다르면 1
	// |			: (두개 이상의 비트값이) 두 비트가 하나라도 1이라면 참

	int a = 10, b = 30, c = 20, max;

	// [삼항연산자(조건연산자) ] 
	//		: (조건) ? a: b 형식으로 .. ()안의 조건이 true면 a : b 중 a가, false면 a : b 중 b가 출력된다 
	max = (a > b) ? a : b;
	max = (max > c) ? max : c;

	printf("가장 큰 수 : %d \n", max);

	return 0;

}