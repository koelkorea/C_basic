// 다중 포인터 : 특정 포인터 변수가 위치하는 주소값을 가지고 있는 또 다른 포인터 변수...
//  -> (설명) 변수a <- 포인터1(변수a의 주소값과 자료형을 아는 포인터변수) <- 다중 포인터1(포인터1의 자료형과 주소값을 아는 또 다른 포인터 변수)

//  - 다중 포인터의 특징
//      : 현재 자신이 참조하고 있는 포인터와 연관된(꼬리가 물려있는) 포인터들 전부의 값을 역참조가 가능하다(= 변수값 변화 추적이 가능하다)

//	- 다중 포인터 변수 선언법 (= 포인터 선언의 확장판)
//		: 자료형 ** 포인터변수명    <- *의 개수를 늘리면 그 만큼 다중 포인터가 가능한 수준이 늘어남...
//			ex) int a = 10;
//              int * pA = &a;          <- int변수 a의 주소를 저장하는 포인터 변수인 pA를 선언
//              int ** ppA = &pA;       <- int형 포인터변수 pa의 주소를 저장하는 2중 포인터변수 ppA 선언
//              int *** pppA = &ppA;    <- int형 2중 포인터변수 ppa의 주소를 저장하는 3중 포인터변수 pppA 선언

//              (역참조시 결론 : 역참조 사용을 *만큼 가능) 
//              * pppA = ppA = &pA     <- 3중 포인터를 *으로 역참조하면 바로 전의 포인터가 저장하는 전전 변수의 주소값이 등장
//              ** pppA = pA = &a      <- 3중 포인터를 *으로 역참조하면 전전의 포인터가 저장하는 전전전 변수의 주소값이 등장
//              ** pppA = a = 10       <- 3중 포인터를 **으로 역참조하면 바로 전의 포인터가 저장하는 전전 변수의 값을 볼 수 있음

#include<stdio.h>

int main() {

  int a = 122;
  int* pA = &a;
  int** ppA = &pA;
  int*** pppA = &ppA;

  printf(" %10s ( %-13s ): %d \n", "a", "= a 값", a);
  printf(" %10s ( %-13s ): %p \n\n", "&a", "= a 주소", &a);

  printf(" %10s ( %-13s ): %d \n", "*pA", "= a 값", *pA);
  printf(" %10s ( %-13s ): %p \n", "pA", "= a 주소", pA);
  printf(" %10s ( %-13s ): %p \n\n", "&pA", "= pA 주소", &pA);

  printf(" %10s ( %-13s ): %d \n", "**ppA", "= a 값", **ppA);
  printf(" %10s ( %-13s ): %p \n", "*ppA", "= a 주소", *ppA);
  printf(" %10s ( %-13s ): %p \n", "ppA", "= pA 주소", ppA);
  printf(" %10s ( %-13s ): %p \n\n", "&ppA", "= ppA 주소", &ppA);

  printf(" %10s ( %-13s ): %d \n", "***pppA", "= a 값", ***pppA);
  printf(" %10s ( %-13s ): %p \n", "**pppA", "= a 주소", **pppA);
  printf(" %10s ( %-13s ): %p \n", "*pppA", "= pA 주소", *pppA);
  printf(" %10s ( %-13s ): %p \n", "pppA", "= ppA 주소", pppA);
  printf(" %10s ( %-13s ): %p \n\n", "&pppA", "= pppA 주소", &pppA);
  
  return 0;
}